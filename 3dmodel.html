<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Prototype Sensor Model — Babylon.js (fixed)</title>
  <style>
    html, body { width:100%; height:100%; margin:0; padding:0; overflow:hidden; background:#f3f5f7; }
    #renderCanvas { width:100%; height:100%; touch-action:none; display:block; }
    .hint { position: absolute; left: 12px; top: 12px; font-family: Arial, Helvetica, sans-serif; color: #333; background: rgba(255,255,255,0.7); padding:6px 8px; border-radius:6px; font-size:13px; }
  </style>

  <!-- Babylon.js CDN -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <script src="https://cdn.babylonjs.com/csg/babylon.csg.js"></script>
</head>
<body>
  <div class="hint">Drag to rotate • Scroll to zoom • Double-click to reset</div>
  <canvas id="renderCanvas"></canvas>

<script>
  const canvas = document.getElementById("renderCanvas");
  const engine = new BABYLON.Engine(canvas, true, {preserveDrawingBuffer:true, stencil:true});

  const createScene = function() {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0.96,0.97,0.98,1);

    // === CAMERA ===
    const camera = new BABYLON.ArcRotateCamera("cam", -Math.PI/2.8, Math.PI/3.5, 1.8, BABYLON.Vector3.Zero(), scene);
    camera.attachControl(canvas, true);
    camera.wheelDeltaPercentage = 0.01;
    camera.lowerRadiusLimit = 0.4;
    camera.upperRadiusLimit = 4;
    camera.minZ = 0.01;

    // === LIGHTS ===
    const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0,1,0), scene);
    hemi.intensity = 0.9;
    const dir = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-0.6,-1,0.2), scene);
    dir.position = new BABYLON.Vector3(5, 5, -5);
    dir.intensity = 1.0;

    // === GROUND ENVIRONMENT ===
    const env = scene.createDefaultEnvironment({
      createSkybox: false,
      createGround: true,
      enableGroundShadow: false
    });
    env.ground.position.y = -0.9;
    env.ground.scaling = new BABYLON.Vector3(2.5, 1, 2.5);
    env.ground.material.diffuseColor = new BABYLON.Color3(0.98,0.98,0.99);

    // === MATERIALS ===
    const bodyMat = new BABYLON.PBRMaterial("bodyMat", scene);
    bodyMat.albedoColor = new BABYLON.Color3(0.96,0.96,0.96);
    bodyMat.roughness = 0.6;
    bodyMat.metallic = 0.05;

    const bottomMat = new BABYLON.PBRMaterial("bottomMat", scene);
    bottomMat.albedoColor = new BABYLON.Color3(0.7, 0.95, 0.9);
    bottomMat.roughness = 0.4;
    bottomMat.metallic = 0.0;

    const ventMat = new BABYLON.StandardMaterial("vent", scene);
    ventMat.diffuseColor = new BABYLON.Color3(0.13,0.16,0.2);

    const portMat = new BABYLON.StandardMaterial("portMat", scene);
    portMat.diffuseColor = new BABYLON.Color3(0.08,0.08,0.08);

    // === ROOT (create early) ===
    const root = new BABYLON.TransformNode("deviceRoot", scene);

    // === MAIN BODY ===
    const bodyRadius = 0.42;
    const bodyHeight = 0.16;
    const body = BABYLON.MeshBuilder.CreateCylinder("body", {
      diameter: bodyRadius * 2,
      height: bodyHeight,
      tessellation: 64
    }, scene);
    body.rotation.x = Math.PI;
    body.position.y = -0.02;
    body.material = bodyMat;
    body.parent = root;

    // === LOWER CYLINDER (base) WITH FLAT CUT ===
    const baseRadius = bodyRadius * 0.95;
    const baseHeight = 0.09;

    const baseFull = BABYLON.MeshBuilder.CreateCylinder("baseFull", {
      diameter: baseRadius * 2,
      height: baseHeight,
      tessellation: 64
    }, scene);
    baseFull.rotation.x = Math.PI;
    baseFull.position.y = -bodyHeight/2 - baseHeight/2 - 0.01;
    baseFull.material = bodyMat;

    // single sideCutBox (was duplicated before)
    const sideCutBox = BABYLON.MeshBuilder.CreateBox("sideCut", {
      width: baseRadius * 2.5,
      height: baseHeight * 2,
      depth: baseRadius * 2
    }, scene);
    sideCutBox.position = new BABYLON.Vector3(baseRadius * 0.8, 0, 0);
    let baseCut;
    try {
      const baseCSG = BABYLON.CSG.FromMesh(baseFull);
      const cutCSG = BABYLON.CSG.FromMesh(sideCutBox);
      const result = baseCSG.subtract(cutCSG);
      baseCut = result.toMesh("baseCut", bodyMat, scene);
      baseFull.dispose();
      sideCutBox.dispose();
    } catch (e) {
      console.warn("CSG failed for base, using full base");
      baseCut = baseFull;
      sideCutBox.dispose();
    }
    baseCut.parent = root;

    // === BOTTOM PLATE ===
    const bottomPlate = BABYLON.MeshBuilder.CreateDisc("bottomPlate", {
      radius: bodyRadius * 0.95,
      tessellation: 64
    }, scene);
    bottomPlate.rotation.x = Math.PI/2;
    bottomPlate.position.y = -bodyHeight/2 - 0.01;
    bottomPlate.material = bottomMat;
    bottomPlate.parent = root;

    // === VENT BAND ===
    const ventBand = BABYLON.MeshBuilder.CreateCylinder("ventBand", {
      diameter: bodyRadius * 2 * 0.98,
      height: 0.03,
      tessellation: 64
    }, scene);
    ventBand.rotation.x = Math.PI;
    ventBand.position.y = -bodyHeight/2 + 0.01;
    ventBand.material = ventMat;
    ventBand.parent = root;

    // === UPPER CYLINDER (topCap) ===
    const topCapRadius = bodyRadius / 2;
    const topCapHeight = 0.08;

    const topCap = BABYLON.MeshBuilder.CreateCylinder("topCap", {
      diameter: topCapRadius * 2,
      height: topCapHeight,
      tessellation: 64
    }, scene);
    topCap.rotation.x = Math.PI;
    topCap.position.y = bodyHeight/2 + topCapHeight/2 - 0.01;
    topCap.material = bodyMat;
    
    // DO NOT parent yet — we'll parent the final mesh after CSG

    // === Side vent holes (to subtract) ===
    const ventHoles = [];
    const holeCount = 8;
    for (let i = 0; i < holeCount; i++) {
      const angle = (i / holeCount) * Math.PI * 2;
      const hole = BABYLON.MeshBuilder.CreateBox("ventHole" + i, {
        width: 0.01,
        height: 0.03,
        depth: 0.02
      }, scene);
      hole.position = new BABYLON.Vector3(
        Math.cos(angle) * topCapRadius * 0.95,
        topCap.position.y,
        Math.sin(angle) * topCapRadius * 0.95
      );
      hole.rotation.y = -angle;
      ventHoles.push(hole);
    }

    // === Create topCapWithVents via CSG, but only dispose originals if CSG succeeded ===
    let topCapWithVents = topCap;
    let csgSucceeded = false;
    try {
      let capCSG = BABYLON.CSG.FromMesh(topCap);
      ventHoles.forEach(h => {
        capCSG = capCSG.subtract(BABYLON.CSG.FromMesh(h));
      });
      topCapWithVents = capCSG.toMesh("topCapVented", bodyMat, scene);
      csgSucceeded = true;
    } catch (e) {
      console.warn("CSG failed on top vents — using solid topCap");
      csgSucceeded = false;
    } finally {
      // Clean up originals only if CSG succeeded (so we don't dispose the mesh we still need)
      if (csgSucceeded) {
        try { topCap.dispose(); } catch(e) {}
        ventHoles.forEach(h => { try { h.dispose(); } catch(e) {} });
      } else {
        // If CSG failed, remove the vent hole helper meshes to avoid clutter
        ventHoles.forEach(h => { try { h.dispose(); } catch(e) {} });
      }
    }

    topCapWithVents.parent = root;

    // === BLACK VERTICAL STRIPES ON TOP CYLINDER ===
    // This block must be AFTER topCapWithVents/topCap is finalized and root exists.
    (function addStripes() {
      const stripeCount = 40;
      const stripeWidth = 0.0005;
      const stripeHeight = topCapHeight * 0.75;
      // put stripes slightly outside to avoid z-fighting with top cap surface
      const stripeRadius = topCapRadius * 1;

      // safe reference to whichever mesh we have
      const topCapMesh = topCapWithVents || topCap;
      if (!topCapMesh || typeof topCapMesh.position === "undefined") {
        console.warn("No top cap mesh available for stripes; skipping stripes.");
        return;
      }

      for (let i = 0; i < stripeCount; i++) {
        const angle = (i / stripeCount) * Math.PI * 2;
        const stripe = BABYLON.MeshBuilder.CreateBox("stripe" + i, {
          width: stripeWidth,
          height: stripeHeight,
          depth: 0.02
        }, scene);

        stripe.material = ventMat;

        stripe.position = new BABYLON.Vector3(
          Math.cos(angle) * stripeRadius,
          topCapMesh.position.y,
          Math.sin(angle) * stripeRadius
        );

        stripe.rotation.y = -angle;
        stripe.parent = root;
      }
    })();



    // === TEXT: "Aura of Safety" ON TOP SURFACE — visible plane, same color as top cylinder ===
(function addTopSurfaceText(){

    const textureSize = 1024;
    const dynamicTexture = new BABYLON.DynamicTexture("topTextTexture", {width: textureSize, height: textureSize}, scene);
    const ctx = dynamicTexture.getContext();

    ctx.clearRect(0, 0, textureSize, textureSize);

    // Крупный белый текст
    ctx.font = "bold 140px Arial";
    ctx.fillStyle = "white";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("Aura of Safety", textureSize / 2, textureSize / 2);

    dynamicTexture.update();

    // Материал под цвет верхнего цилиндра
    const textMat = new BABYLON.StandardMaterial("topTextMat", scene);
    textMat.diffuseTexture = dynamicTexture;
    textMat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3);
    // ← цвет совпадает с верхней крышкой
    textMat.emissiveColor = new BABYLON.Color3(1,1,1);    // ← текст яркий, самосветящийся
    textMat.specularColor = new BABYLON.Color3(0.1,0.1,0.1);

    // Уменьшенная плоскость
    const textPlane = BABYLON.MeshBuilder.CreatePlane("topTextPlane", {
        width: topCapRadius * 1.2,
        height: topCapRadius * 1.2
    }, scene);

    // Позиция — верхняя плоскость цилиндра
    textPlane.position = new BABYLON.Vector3(
        0,
        topCapWithVents.position.y + topCapHeight / 2 + 0.001,
        0
    );

    textPlane.rotation.x = Math.PI / 2;
    textPlane.material = textMat;
    textPlane.parent = root;
})();


        // === TOP BUTTON (black sphere) ===
    const buttonRadius = 0.015;

    const topButton = BABYLON.MeshBuilder.CreateSphere("topButton", {
    diameter: buttonRadius * 2,
    segments: 32
    }, scene);

    // позиция: верхний край серединного цилиндра
    topButton.position = new BABYLON.Vector3(
    0, 
    topButton.position.y = topCapWithVents.position.y + topCapHeight / 2 - buttonRadius - 0.08, 
    0
    );
    topButton.position.x = topCapRadius * 1.7;
    const buttonMat = new BABYLON.StandardMaterial("buttonMat", scene);
    buttonMat.diffuseColor = new BABYLON.Color3(0.05, 0.05, 0.05);
    buttonMat.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
    topButton.material = buttonMat;

    topButton.parent = root;





    // === PORTS (on flat side of lower cylinder) ===
    const usbWidth = 0.04, usbHeight = 0.01, usbDepth = 0.043;
    const ethWidth = 0.05, ethHeight = 0.045  , ethDepth = 0.07;

    const usbPort = BABYLON.MeshBuilder.CreateBox("usbPort", { width: usbWidth, height: usbHeight, depth: usbDepth }, scene);
    const ethPort = BABYLON.MeshBuilder.CreateBox("ethPort", { width: ethWidth, height: ethHeight, depth: ethDepth }, scene);

    usbPort.position = new BABYLON.Vector3(baseRadius - 0.778, -0.14, -0.02);
    ethPort.position = new BABYLON.Vector3(baseRadius - 0.770, -0.14, 0.08);
    usbPort.material = portMat;
    ethPort.material = portMat;
    usbPort.parent = root;
    ethPort.parent = root;

    // === AUTO ROTATION ===
    scene.onBeforeRenderObservable.add(()=> {
      const t = performance.now() * 0.00008;
      root.rotation.y = t;
    });

    // === DOUBLE CLICK RESET CAMERA ===
    canvas.addEventListener("dblclick", ()=> {
      camera.setTarget(BABYLON.Vector3.Zero());
      camera.alpha = -Math.PI/2.8;
      camera.beta = Math.PI/3.5;
      camera.radius = 1.8;
    });

    return scene;
  };

  const scene = createScene();
  engine.runRenderLoop(()=> scene.render());

  window.addEventListener("resize", ()=> engine.resize());
</script>
</body>
</html>